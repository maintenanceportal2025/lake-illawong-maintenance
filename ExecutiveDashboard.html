<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lake Illawong - Executive Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
<script src="https://unpkg.com/html2canvas@latest/dist/html2canvas.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(90deg, #1e40af 0%, #1e3a8a 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .dashboard-container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

[data-theme="dark"] {
    --primary-blue: #60a5fa;
    --secondary-blue: #3b82f6;
    --accent-blue: #93c5fd;
    --success-green: #34d399;
    --warning-yellow: #fbbf24;
    --danger-red: #f87171;
    --text-dark: #f1f5f9;
    --text-light: #cbd5e1;
    --background-light: #0f172a;
    --surface-white: #1e293b;
    --border-light: #334155;
}

body[data-theme="dark"] {
    background: linear-gradient(90deg, #1e293b 0%, #0f172a 100%);
}

[data-theme="dark"] .dashboard-container {
    background: var(--surface-white);
    color: var(--text-dark);
}

        /* Header */
        .dashboard-header {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            padding: 30px 40px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .header-left p {
            opacity: 0.9;
            font-size: 1rem;
        }

        .header-right {
            text-align: right;
        }

        .last-updated {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .refresh-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .refresh-btn:hover {
            background: white;
            color: #1e3a8a;
        }

        .dataset-btn {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
            transition: all 0.3s;
        }

        .dataset-btn:hover {
            background: rgba(255,255,255,0.3);
            border-color: rgba(255,255,255,0.6);
        }

        .dataset-btn.active {
            background: white;
            color: #1e3a8a;
            border-color: white;
        }

        #datasetBadge {
            padding: 4px 12px;
            background: rgba(255,255,255,0.2);
            border-radius: 6px;
            font-weight: 600;
        }

        /* Main Layout */
        .dashboard-main {
            display: flex;
            min-height: calc(100vh - 140px);
        }

        /* Slicer Panel */
        .slicer-panel {
            width: 280px;
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
            padding: 20px;
            overflow-y: auto;
        }

        .slicer-section {
            margin-bottom: 25px;
        }

        .slicer-header {
            font-weight: 700;
            color: #1e293b;
            font-size: 0.9rem;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #3b82f6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .slicer-header:hover {
            color: #3b82f6;
        }

        .slicer-header .expand-icon {
            font-size: 0.8rem;
            transition: transform 0.3s;
        }

        .slicer-header.collapsed .expand-icon {
            transform: rotate(-90deg);
        }

        .slicer-content {
    max-height: 400px;
    overflow-y: auto;
    overflow-x: hidden;
    transition: max-height 0.3s ease-out;
}

        .slicer-content.collapsed {
            max-height: 0;
        }

        .clear-filter {
            font-size: 0.75rem;
            color: #3b82f6;
            cursor: pointer;
            font-weight: 500;
        }

        .clear-filter:hover {
            text-decoration: underline;
        }

        .slicer-item {
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slicer-item:hover {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        .slicer-item.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .slicer-badge {
            background: rgba(0,0,0,0.1);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .slicer-item.active .slicer-badge {
            background: rgba(255,255,255,0.3);
        }

        .date-picker-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .date-input {
            padding: 8px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.85rem;
            width: 100%;
        }

        .date-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .apply-date-btn {
            padding: 8px 12px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .apply-date-btn:hover {
            background: #2563eb;
        }

        .clear-all-btn {
            width: 100%;
            padding: 12px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .clear-all-btn:hover {
            background: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239,68,68,0.4);
        }

        /* Content Area */
        .content-area {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }

        /* KPI Cards */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .kpi-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-left: 4px solid #3b82f6;
            transition: all 0.3s;
        }

        .kpi-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }

        .kpi-card.danger {
            border-left-color: #ef4444;
        }

        .kpi-card.warning {
            border-left-color: #f59e0b;
        }

        .kpi-card.success {
            border-left-color: #10b981;
        }

        .kpi-label {
            font-size: 0.85rem;
            color: #64748b;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .kpi-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 5px;
        }

        .kpi-sublabel {
            font-size: 0.8rem;
            color: #94a3b8;
        }

        .kpi-trend {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.85rem;
            margin-top: 10px;
            padding: 5px 10px;
            border-radius: 6px;
        }

        .kpi-trend.up {
            background: #dcfce7;
            color: #166534;
        }

        .kpi-trend.down {
            background: #fee2e2;
            color: #991b1b;
        }

        /* Chart Grid */
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .chart-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .chart-header {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        .chart-container {
            position: relative;
            height: 300px;
        }

        /* Full Width Charts */
        .full-width-chart {
            grid-column: 1 / -1;
        }

        /* Loading State */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* Filter Summary */
        .filter-summary {
            background: #eff6ff;
            border: 2px solid #3b82f6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .filter-summary-title {
            font-weight: 700;
            color: #1e40af;
            margin-bottom: 8px;
        }

        .filter-tag {
            display: inline-block;
            background: #3b82f6;
            color: white;
            padding: 5px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            margin: 3px;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .dashboard-main {
                flex-direction: column;
            }

            .slicer-panel {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
            }

            .chart-grid {
                grid-template-columns: 1fr;
            }
        }



/* ===== NUCLEAR PDF MODAL OVERRIDE ===== */
body #pdfModal.modal {
    display: none !important;
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: rgba(0,0,0,0.6) !important;
    backdrop-filter: blur(5px) !important;
    z-index: 10000 !important;
    align-items: center !important;
    justify-content: center !important;
}

body #pdfModal.modal:not(.hidden) {
    display: flex !important;
}

body #pdfModal .modal-content {
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%) !important;
    margin: 0 !important;
    padding: 0 !important;
    border-radius: 16px !important;
    width: 90% !important;
    max-width: 500px !important;
    box-shadow: 0 20px 60px rgba(0,0,0,0.3) !important;
    border: 1px solid rgba(255,255,255,0.1) !important;
    overflow: hidden !important;
}

body #pdfModal .modal-content h3 {
    background: rgba(255,255,255,0.1) !important;
    color: white !important;
    margin: 0 !important;
    padding: 25px !important;
    font-size: 1.5rem !important;
    font-weight: 600 !important;
    text-align: center !important;
    border-bottom: 1px solid rgba(255,255,255,0.1) !important;
}

body #pdfModal .modal-content p {
    color: rgba(255,255,255,0.9) !important;
    margin: 0 0 25px 0 !important;
    padding: 0 25px !important;
    font-size: 1rem !important;
    text-align: center !important;
}

body #pdfModal .modal-section {
    margin: 0 25px 25px 25px !important;
    padding: 0 !important;
}

body #pdfModal .modal-section h4 {
    color: white !important;
    margin-bottom: 15px !important;
    font-size: 1.1rem !important;
    font-weight: 600 !important;
}

/* Orientation */
body #pdfModal .orientation-options {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 15px !important;
    margin: 0 !important;
    padding: 0 !important;
}

body #pdfModal .orientation-option {
    display: block !important;
    cursor: pointer !important;
    margin: 0 !important;
    padding: 0 !important;
}

body #pdfModal .orientation-option input {
    display: none !important;
}

body #pdfModal .orientation-preview {
    background: rgba(255,255,255,0.1) !important;
    border: 2px solid rgba(255,255,255,0.2) !important;
    border-radius: 12px !important;
    padding: 20px 15px !important;
    text-align: center !important;
    transition: all 0.3s ease !important;
    color: white !important;
    backdrop-filter: blur(10px) !important;
}

body #pdfModal .orientation-option input:checked + .orientation-preview {
    background: rgba(255,255,255,0.2) !important;
    border-color: rgba(255,255,255,0.5) !important;
    transform: translateY(-2px) !important;
}

body #pdfModal .orientation-preview:hover {
    border-color: rgba(255,255,255,0.4) !important;
    background: rgba(255,255,255,0.15) !important;
}

body #pdfModal .landscape-icon,
body #pdfModal .portrait-icon {
    font-size: 2.5rem !important;
    margin-bottom: 10px !important;
    display: block !important;
}

/* Layout */
body #pdfModal .modal-options {
    display: flex !important;
    flex-direction: column !important;
    gap: 15px !important;
    margin: 0 !important;
    padding: 0 !important;
}

body #pdfModal .modal-option {
    display: flex !important;
    align-items: center !important;
    padding: 20px !important;
    background: rgba(255,255,255,0.1) !important;
    border: 2px solid rgba(255,255,255,0.2) !important;
    border-radius: 12px !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    backdrop-filter: blur(10px) !important;
    color: white !important;
}

body #pdfModal .modal-option:hover {
    border-color: rgba(255,255,255,0.4) !important;
    background: rgba(255,255,255,0.15) !important;
    transform: translateY(-2px) !important;
}

body #pdfModal .option-icon {
    font-size: 2rem !important;
    margin-right: 15px !important;
}

body #pdfModal .option-text strong {
    display: block !important;
    color: white !important;
    margin-bottom: 5px !important;
    font-size: 1.1rem !important;
}

body #pdfModal .option-text small {
    color: rgba(255,255,255,0.8) !important;
    font-size: 0.9rem !important;
}

/* Actions */
body #pdfModal .modal-actions {
    display: flex !important;
    justify-content: flex-end !important;
    padding: 20px 25px !important;
    background: rgba(0,0,0,0.2) !important;
    border-top: 1px solid rgba(255,255,255,0.1) !important;
    margin: 0 !important;
}

body #pdfModal .modal-cancel {
    background: rgba(255,255,255,0.1) !important;
    color: white !important;
    border: 1px solid rgba(255,255,255,0.2) !important;
    padding: 12px 25px !important;
    border-radius: 8px !important;
    cursor: pointer !important;
    font-weight: 600 !important;
}

/* Add spacing between chart titles and export buttons */
.chart-header {
    display: flex !important;
    justify-content: space-between !important;
    align-items: center !important;
    margin-bottom: 20px !important;
    padding-bottom: 15px !important;
    border-bottom: 2px solid #e2e8f0 !important;
}

.chart-header h3 {
    margin: 0 !important;
    padding: 0 !important;
    flex: 1 !important;
}

.chart-header button {
    margin-left: 15px !important;
    white-space: nowrap !important;
}


    </style>
</head>
<body>

<!-- PDF Export Modal -->
<div id="pdfModal" class="modal hidden">

    <div class="modal-content">
        <h3>üìÑ PDF Export Options</h3>
        <p>Choose your preferred PDF layout:</p>
        
        <div class="modal-section">
            <h4>üìê Orientation</h4>
            <div class="orientation-options">
                <label class="orientation-option">
                    <input type="radio" name="orientation" value="landscape" checked>
                    <div class="orientation-preview">
                        <div class="landscape-icon">üñ•Ô∏è</div>
                        <span>Landscape</span>
                    </div>
                </label>
                <label class="orientation-option">
                    <input type="radio" name="orientation" value="portrait">
                    <div class="orientation-preview">
                        <div class="portrait-icon">üì±</div>
                        <span>Portrait</span>
                    </div>
                </label>
            </div>
        </div>

        <div class="modal-section">
            <h4>üìä Layout</h4>
            <div class="modal-options">

                <div class="modal-option" onclick="exportPDF('single')">
                    <div class="option-icon">üìã</div>
                    <div class="option-text">
                        <strong>Single Page</strong>
                        <small>All charts on one page (compact)</small>
                    </div>
                </div>
                
                <div class="modal-option" onclick="exportPDF('multi')">
                    <div class="option-icon">üìë</div>
                    <div class="option-text">
                        <strong>Multi Page</strong>
                        <small>One chart per page (high quality)</small>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="modal-actions">
            <button class="modal-cancel" onclick="closePDFModal()">Cancel</button>
        </div>
    </div>
</div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

<!-- HEADER WITH LOGO -->
        <div class="header-section" style="background: linear-gradient(90deg, #1e40af 0%, #1e3a8a 100%); color: white; padding: 30px 0;">
            <div class="container">
                <!-- Centered Logo and Title -->
                <div style="display: flex; align-items: center; justify-content: center; gap: 25px; margin-bottom: 25px;">
                    <!-- Logo -->
                    <div style="flex-shrink: 0;">
                        <img src="logo.png" 
                             alt="Lake Illawong Logo" 
                             style="width: 120px; height: 120px; object-fit: contain; background: transparent;">
                    </div>
                    <!-- Title -->
                    <div style="text-align: left;">
                        <h1 style="display: block; font-size: 2em; margin-block-start: 0.67em; margin-block-end: 0.67em; margin-inline-start: 0px; font-weight: bold; color: white; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);">Executive Dashboard</h1>
                        <p style="color: white; font-size: 1rem; margin: 0; font-weight: 600; letter-spacing: 2px; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); ">Real-Time Analytics</p>
                    </div>
                </div>
                
                <!-- Last Updated - Centered -->
                <div style="text-align: center; margin-bottom: 25px;">
                    <div class="last-updated" id="lastUpdated" style="font-size: 0.9rem; opacity: 0.9;">Last updated: Loading...</div>
                </div>
                
                <!-- Data Source Selection Row -->
                <div style="display: flex; align-items: end; justify-content: space-between;">
                    <!-- Left: Data Source Selection with Badge -->
                    <div>
                        <div style="font-size: 0.75rem; opacity: 0.9; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;">
                            üìä Data Source Selection
                        </div>
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <div style="background: rgba(255,255,255,0.15); padding: 8px; border-radius: 8px; border: 2px solid rgba(255,255,255,0.3); display: inline-flex; gap: 10px;">
                                <button class="dataset-btn active" id="allDataBtn" onclick="switchDataset('all')">üîÑ All Data</button>
                                <button class="dataset-btn" id="currentDataBtn" onclick="switchDataset('current')">üìä Current</button>
                                <button class="dataset-btn" id="legacyDataBtn" onclick="switchDataset('legacy')">üìö Legacy</button>
                            </div>
                            <span id="datasetBadge" style="background: rgba(255,255,255,0.2); padding: 6px 16px; border-radius: 8px; font-weight: 600; font-size: 0.85rem;">Combined Dataset</span>
                        </div>
                    </div>


                    
                    <!-- Right: Refresh Button -->
                    <div style="display: flex; gap: 10px; align-items: center;">
    <button class="refresh-btn" onclick="loadData()" style="padding: 8px 20px; font-size: 0.9rem;">üîÑ Refresh Data</button>

    <button class="refresh-btn" onclick="showPDFOptions()" style="padding: 8px 15px; font-size: 0.9rem;">üìÑ PDF</button>


    <button class="refresh-btn" onclick="exportPNG()" style="padding: 8px 15px; font-size: 0.9rem;">üñºÔ∏è PNG</button>
    <button class="refresh-btn" onclick="exportCSV()" style="padding: 8px 15px; font-size: 0.9rem;">üìä CSV</button>
    <button class="refresh-btn" onclick="toggleTheme()" style="padding: 8px 15px; font-size: 0.9rem;">üåì Theme</button>
</div>


                </div>
            </div>
        </div>



    <div class="dashboard-container">


        <!-- Main Content -->
        <div class="dashboard-main">
            <!-- Slicer Panel -->
            <div class="slicer-panel">
                <div class="slicer-section" style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 15px;">
                    <div class="slicer-header" style="border-bottom-color: #f59e0b;">
                        üîß PROGRAMMED STATUS
                    </div>
                    <div style="font-size: 0.75rem; color: #92400e; margin-bottom: 10px; line-height: 1.4;">
                        Long-term maintenance programs (e.g., dormer windows). Click to view ONLY programmed items.
                    </div>
                    <div class="slicer-item" id="programmedSlicer" onclick="toggleProgrammedOnlyFilter()" style="cursor: pointer;">
                        <span>View Programmed Only</span>
                        <span class="slicer-badge" id="programmedCount">0</span>
                    </div>
                </div>


<!-- Chart Selection -->
<div class="slicer-section" style="background: #fef3c7; border: 2px solid #f59e0b; margin-bottom: 25px;">
    <div class="slicer-header" style="background: #f59e0b; color: white; padding: 15px; font-weight: 700;">
        üìä CHART SELECTION
    </div>
    <div class="slicer-content" style="padding: 20px;">
        <div style="display: grid; gap: 10px;">
            <!-- Original Charts - Now Dynamic -->
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="priorityToggle" onchange="toggleChart('priority')" style="transform: scale(1.2);" checked>
                <span>üö® Priority Distribution</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="statusToggle" onchange="toggleChart('status')" style="transform: scale(1.2);" checked>
                <span>üìä Status Pipeline</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="categoryToggle" onchange="toggleChart('category')" style="transform: scale(1.2);" checked>
                <span>üìÅ Top 10 Categories</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="zoneToggle" onchange="toggleChart('zone')" style="transform: scale(1.2);" checked>
                <span>üó∫Ô∏è Zone Distribution</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="trendToggle" onchange="toggleChart('trend')" style="transform: scale(1.2);" checked>
                <span>üìà 6-Month Trend</span>
            </label>
            
            <!-- New Dynamic Charts -->
            <hr style="margin: 15px 0; border-color: #f59e0b;">
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="gaugeToggle" onchange="toggleChart('gauge')" style="transform: scale(1.2);">
                <span>‚è±Ô∏è Completion Rate Gauge</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="heatmapToggle" onchange="toggleChart('heatmap')" style="transform: scale(1.2);">
                <span>üî• Monthly Problem Heatmap</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="comparisonToggle" onchange="toggleChart('comparison')" style="transform: scale(1.2);">
                <span>üìä Year-over-Year Comparison</span>
            </label>
            <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                <input type="checkbox" id="unitsToggle" onchange="toggleChart('units')" style="transform: scale(1.2);">
                <span>üè† Top 10 Most Reported Units</span>
            </label>
        </div>
    </div>
</div>

                <div class="slicer-section">
                    <div class="slicer-header collapsed" onclick="toggleSlicerSection(this)">
                        <span>üìÖ TIME PERIOD</span>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="slicer-content collapsed">
                        <div id="dateSlicers"></div>
                        <div class="date-picker-container">
                            <label style="font-size: 0.8rem; color: #64748b; font-weight: 600;">Custom Date Range:</label>
                            <input type="date" id="customStartDate" class="date-input" placeholder="Start Date">
                            <input type="date" id="customEndDate" class="date-input" placeholder="End Date">
                            <button class="apply-date-btn" onclick="applyCustomDateRange()">Apply Custom Range</button>
                        </div>
                    </div>
                </div>

                <div class="slicer-section">
                    <div class="slicer-header collapsed" onclick="toggleSlicerSection(this)">
                        <span>üö® PRIORITY</span>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="slicer-content collapsed">
                        <div id="prioritySlicers"></div>
                    </div>
                </div>

                <div class="slicer-section">
                    <div class="slicer-header collapsed" onclick="toggleSlicerSection(this)">
                        <span>üìä STATUS</span>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="slicer-content collapsed">
                        <div id="statusSlicers"></div>
                    </div>
                </div>

                <div class="slicer-section">
                    <div class="slicer-header collapsed" onclick="toggleSlicerSection(this)">
                        <span>üó∫Ô∏è ZONES</span>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="slicer-content collapsed">
                        <div id="zoneSlicers"></div>
                    </div>
                </div>

                <div class="slicer-section">
                    <div class="slicer-header collapsed" onclick="toggleSlicerSection(this)">
                        <span>üìÅ CATEGORIES</span>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="slicer-content collapsed">
                        <div id="categorySlicers"></div>
                    </div>
                </div>

                <div class="slicer-section">
                    <div class="slicer-header collapsed" onclick="toggleSlicerSection(this)">
                        <span>üìÇ SUB-CATEGORIES</span>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="slicer-content collapsed">
                        <div id="subCategorySlicers"></div>
                    </div>
                </div>

                <div class="slicer-section">
                    <div class="slicer-header collapsed" onclick="toggleSlicerSection(this)">
                        <span>üë∑ ASSIGNED TO</span>
                        <span class="expand-icon">‚ñº</span>
                    </div>
                    <div class="slicer-content collapsed">
                        <div id="assignedToSlicers"></div>
                    </div>
                </div>

                <button class="clear-all-btn" onclick="toggleAllFilters()" id="toggleAllBtn">üóëÔ∏è CLEAR ALL FILTERS</button>
            </div>

            <!-- Content Area -->
            <div class="content-area">
                <!-- Filter Summary -->
                <div id="filterSummary" class="filter-summary hidden">
                    <div class="filter-summary-title">Active Filters:</div>
                    <div id="filterTags"></div>
                </div>

                <!-- KPI Cards -->
                <div class="kpi-grid" id="kpiGrid"></div>

                <!-- Charts -->


                <!-- Dynamic Charts Container -->
<div class="chart-grid" id="chartGrid">
    <!-- Charts will be created dynamically here -->
</div>

    <script>



// DEBUG: Check if functions exist when script loads
console.log('=== SCRIPT LOADING ===');
console.log('showPDFOptions function exists:', typeof showPDFOptions);
console.log('closePDFModal function exists:', typeof closePDFModal);
console.log('pdfModal element exists:', document.getElementById('pdfModal') ? 'YES' : 'NO');




// PDF Modal Functions
function showPDFOptions() {
    document.getElementById('pdfModal').classList.remove('hidden');
}

function closePDFModal() {
    document.getElementById('pdfModal').classList.add('hidden');
}






// PDF Export Functions
async function exportPDF(mode = 'single') {
    closePDFModal();
    alert(`Export PDF called with mode: ${mode}`);
    // Rest of the function...
    
    try {
        if (typeof window.jspdf === 'undefined' || typeof html2canvas === 'undefined') {
            alert('PDF libraries not loaded. Please refresh and try again.');
            return;
        }

        const { jsPDF } = window.jspdf;
        
        // Get selected orientation
        const selectedOrientation = document.querySelector('input[name="orientation"]:checked').value;
        
        if (mode === 'single') {
            await exportSinglePagePDF(jsPDF, selectedOrientation);
        } else {
            await exportMultiPagePDF(jsPDF, selectedOrientation);
        }
        
    } catch (error) {
        console.error('PDF export error:', error);
        alert(`Error exporting PDF: ${error.message}`);
    }
}

// Helper function to get active filter summary
function getActiveFilterSummary() {
    const activeFiltersList = [];
    
    if (activeFilters.programmedOnly) activeFiltersList.push('Programmed Only');
    if (activeFilters.date) activeFiltersList.push(`Date: ${activeFilters.date}`);
    if (activeFilters.priorities.length > 0) activeFiltersList.push(`Priorities: ${activeFilters.priorities.join(', ')}`);
    if (activeFilters.statuses.length > 0) activeFiltersList.push(`Statuses: ${activeFilters.statuses.join(', ')}`);
    if (activeFilters.zones.length > 0) activeFiltersList.push(`Zones: ${activeFilters.zones.join(', ')}`);
    
    return activeFiltersList.length > 0 ? activeFiltersList.join('; ') : 'None';
}


// Multi Page - Fixed emojis and better chart handling

async function exportMultiPagePDF(jsPDF, orientation) {
    const isLandscape = orientation === 'landscape';
    const pdf = new jsPDF(isLandscape ? 'l' : 'p', 'mm', 'a4');
    
    // Add header to first page
    pdf.setFontSize(18);
    pdf.text('Lake Illawong Executive Dashboard', 20, 20);
    pdf.setFontSize(10);
    pdf.text(`Generated: ${new Date().toLocaleString('en-AU')}`, 20, 30);
    pdf.text(`Total Problems: ${filteredProblems.length}`, 20, 36);
    pdf.text(`Active Filters: ${getActiveFilterSummary().replace(/[üîßüìÖüö®üìäüó∫Ô∏èüìÅüìÇüë∑]/g, '')}`, 20, 42); // Remove emojis
    
    let currentPage = 1;
    const margin = 20;
    const pageWidth = isLandscape ? 297 : 210;
    const pageHeight = isLandscape ? 210 : 297;

    // Get individual chart cards
    const chartContainers = Array.from(document.querySelectorAll('.chart-card:not(.hidden)'));
    
    for (let i = 0; i < chartContainers.length; i++) {
        const container = chartContainers[i];
        const chartTitleElement = container.querySelector('.chart-header h3');
        const chartCanvas = container.querySelector('canvas');
        
        // Add new page for each chart (except first)
        if (i > 0) {
            pdf.addPage();
            currentPage++;
        }
        
        // Add chart title (remove emojis)
        if (chartTitleElement) {
            const titleText = chartTitleElement.textContent.replace(/[üö®üìäüìÅüó∫Ô∏èüìà‚è±Ô∏èüî•üìäüè†]/g, '');
            pdf.setFontSize(14);
            pdf.text(titleText, margin, 50);
        }
        



      if (chartCanvas && charts[getChartIdFromCanvas(chartCanvas)]) {
    try {
        const chart = charts[getChartIdFromCanvas(chartCanvas)];
        const isPieChart = chart.config.type === 'doughnut' || chart.config.type === 'pie';
        
        let chartDataURL;
        
        if (isPieChart) {
            console.log('Creating isolated square pie chart for PDF...');
            
            // Create a temporary container that's completely isolated
            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'fixed';
            tempContainer.style.left = '-9999px'; // Move off-screen
            tempContainer.style.top = '0';
            tempContainer.style.width = '400px';
            tempContainer.style.height = '400px';
            tempContainer.style.background = 'white';
            tempContainer.style.zIndex = '9999';
            document.body.appendChild(tempContainer);
            
            // Create canvas inside the isolated container
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 400;
            tempCanvas.height = 400;
            tempContainer.appendChild(tempCanvas);
            
            // Clone and render the chart in isolation
            const tempChart = new Chart(tempCanvas, {
                type: chart.config.type,
                data: JSON.parse(JSON.stringify(chart.config.data)),
                options: {
                    ...chart.config.options,
                    responsive: false,
                    maintainAspectRatio: false,
                    animation: false
                }
            });
            
            // Wait for render and capture
            await new Promise(resolve => setTimeout(resolve, 500));
            chartDataURL = tempCanvas.toDataURL('image/png', 1.0);
            
            // Clean up
            tempChart.destroy();
            document.body.removeChild(tempContainer);
        } else {
            chartDataURL = chartCanvas.toDataURL('image/png', 1.0);
        }
        
        if (isPieChart) {
            const chartSize = 100;
            const xPos = margin + ((pageWidth - (margin * 2) - chartSize) / 2);
            pdf.addImage(chartDataURL, 'PNG', xPos, 65, chartSize, chartSize);
            console.log('Isolated pie chart added to PDF');
        } else {
            const chartWidth = pageWidth - (margin * 2);
            const chartHeight = 120;
            pdf.addImage(chartDataURL, 'PNG', margin, 65, chartWidth, chartHeight);
        }
    } catch (error) {
        console.log('Direct export failed:', error);
        await captureChartWithHtml2canvas(container, pdf, margin, 65, pageWidth);
    }
}



        
        // Add page number
        pdf.setFontSize(10);
        pdf.text(`Page ${currentPage} of ${chartContainers.length}`, margin, pageHeight - 10);
    }
    
    const orientationText = isLandscape ? 'landscape' : 'portrait';
    pdf.save(`lake-illawong-dashboard-${orientationText}-${Date.now()}.pdf`);
    alert(`‚úÖ PDF exported! ${chartContainers.length} charts.`);
}

// Helper function to get chart ID from canvas
function getChartIdFromCanvas(canvas) {
    const chartIds = Object.keys(charts);
    for (const id of chartIds) {
        if (charts[id] && charts[id].canvas === canvas) {
            return id;
        }
    }
    return null;
}

// Helper function for html2canvas capture with circular chart support
async function captureChartWithHtml2canvas(container, pdf, margin, startY, pageWidth) {
    container.scrollIntoView({ behavior: 'smooth', block: 'center' });
    await new Promise(resolve => setTimeout(resolve, 800));
    
    const chartTitleElement = container.querySelector('.chart-header h3');
    const chartCanvas = container.querySelector('canvas');
    
    // Only treat as pie chart if it's specifically a doughnut/pie chart
    let isPieChart = false;
    if (chartCanvas && charts[getChartIdFromCanvas(chartCanvas)]) {
        const chart = charts[getChartIdFromCanvas(chartCanvas)];
        isPieChart = chart.config.type === 'doughnut' || chart.config.type === 'pie';
    }
    
    const canvas = await html2canvas(container, {
        scale: 2,
        useCORS: true,
        allowTaint: true,
        backgroundColor: '#ffffff',
        logging: false
    });
    
    const imgData = canvas.toDataURL('image/png', 1.0);
    
    if (isPieChart) {
        // For pie charts, use square capture but maintain aspect ratio
        const containerRect = container.getBoundingClientRect();
        const aspectRatio = containerRect.width / containerRect.height;
        
        const maxChartSize = 80;
        let chartWidth, chartHeight;
        
        if (aspectRatio > 1) {
            chartWidth = maxChartSize;
            chartHeight = maxChartSize / aspectRatio;
        } else {
            chartHeight = maxChartSize;
            chartWidth = maxChartSize * aspectRatio;
        }
        
        const xPos = margin + ((pageWidth - (margin * 2) - chartWidth) / 2);
        pdf.addImage(imgData, 'PNG', xPos, startY, chartWidth, chartHeight);
    } else {
        // Rectangular dimensions for other charts
        const chartWidth = pageWidth - (margin * 2);
        const chartHeight = (canvas.height * chartWidth) / canvas.width;
        pdf.addImage(imgData, 'PNG', margin, startY, chartWidth, Math.min(chartHeight, 120));
    }
}



// Single Page - Proper grid continuation across pages (Simplified)
async function exportSinglePagePDF(jsPDF, orientation) {
    const isLandscape = orientation === 'landscape';
    const pdf = new jsPDF(isLandscape ? 'l' : 'p', 'mm', 'a4');
    
    // Header
    pdf.setFontSize(16);
    pdf.text('Lake Illawong Executive Dashboard', 15, 15);
    pdf.setFontSize(8);
    pdf.text(`Generated: ${new Date().toLocaleString('en-AU')} | Problems: ${filteredProblems.length}`, 15, 22);

    const margin = 15;
    const pageWidth = isLandscape ? 297 : 210;
    const pageHeight = isLandscape ? 210 : 297;
    
    // Grid settings
    const chartsPerRow = 2;
    const chartWidth = (pageWidth - (margin * (chartsPerRow + 1))) / chartsPerRow;
    const chartHeight = 70;
    const rowSpacing = 20;
    
    let currentPage = 1;
    let chartsOnCurrentPage = 0;
    
    // Get all charts
    const chartContainers = Array.from(document.querySelectorAll('.chart-card:not(.hidden)'));
    
    for (let i = 0; i < chartContainers.length; i++) {
        const container = chartContainers[i];
        const chartTitleElement = container.querySelector('.chart-header h3');
        
        // Check if we need a new page (4 charts per page in 2x2 grid)
        if (chartsOnCurrentPage >= 4 && i > 0) {
            // Add footer to current page
            pdf.setFontSize(10);
            pdf.text(`Page ${currentPage}`, margin, pageHeight - 10);
            
            pdf.addPage();
            currentPage++;
            chartsOnCurrentPage = 0;
        }
        
        // Calculate position on current page (2x2 grid)
        const row = Math.floor(chartsOnCurrentPage / chartsPerRow);
        const col = chartsOnCurrentPage % chartsPerRow;
        
        const xPos = margin + (col * (chartWidth + margin));
        const yPos = 35 + (row * (chartHeight + rowSpacing));
        
        // Add chart
        await addChartToSinglePage(container, pdf, xPos, yPos, chartWidth, chartHeight);
        
        if (chartTitleElement) {
            const titleText = chartTitleElement.textContent.replace(/[üö®üìäüìÅüó∫Ô∏èüìà‚è±Ô∏èüî•üìäüè†]/g, '').trim();
            pdf.setFontSize(9);
            pdf.text(titleText, xPos, yPos - 5);
        }
        
        chartsOnCurrentPage++;
    }
    
    // Add final page footer
    pdf.setFontSize(10);
    pdf.text(`Page ${currentPage}`, margin, pageHeight - 10);
    
    const orientationText = isLandscape ? 'landscape' : 'portrait';
    pdf.save(`lake-illawong-single-page-${orientationText}-${Date.now()}.pdf`);
    alert(`‚úÖ Single-page PDF exported! ${chartContainers.length} charts across ${currentPage} pages.`);
}





// Helper function to add a chart to single-page PDF
async function addChartToSinglePage(container, pdf, x, y, width, height) {
    const chartCanvas = container.querySelector('canvas');
    
    if (chartCanvas && charts[getChartIdFromCanvas(chartCanvas)]) {
        try {
            const chart = charts[getChartIdFromCanvas(chartCanvas)];
            const isPieChart = chart.config.type === 'doughnut' || chart.config.type === 'pie';
            
            let chartDataURL;
            
            if (isPieChart) {
                // Use isolated pie chart method for perfect circles
                chartDataURL = await createIsolatedPieChart(chart, 200); // Smaller for single page
            } else {
                chartDataURL = chartCanvas.toDataURL('image/png', 1.0);
            }
            
            // For pie charts, use square dimensions within the allocated space
            if (isPieChart) {
                const pieSize = Math.min(width, height) * 0.8; // 80% of allocated space
                const pieX = x + (width - pieSize) / 2;
                const pieY = y + (height - pieSize) / 2;
                pdf.addImage(chartDataURL, 'PNG', pieX, pieY, pieSize, pieSize);
            } else {
                pdf.addImage(chartDataURL, 'PNG', x, y, width, height);
            }
        } catch (error) {
            console.log('Direct export failed, using html2canvas');
            await captureChartForSinglePage(container, pdf, x, y, width, height);
        }
    } else {
        await captureChartForSinglePage(container, pdf, x, y, width, height);
    }
}

// Helper for html2canvas capture in single page layout
async function captureChartForSinglePage(container, pdf, x, y, width, height) {
    const canvas = await html2canvas(container, {
        scale: 0.5, // Lower scale for smaller images
        useCORS: true,
        backgroundColor: '#ffffff',
        logging: false
    });
    
    const imgData = canvas.toDataURL('image/png', 0.9);
    pdf.addImage(imgData, 'PNG', x, y, width, height);
}

// Helper function to create isolated pie chart (reusable)
async function createIsolatedPieChart(chart, size = 400) {
    return new Promise((resolve) => {
        const tempContainer = document.createElement('div');
        tempContainer.style.position = 'fixed';
        tempContainer.style.left = '-9999px';
        tempContainer.style.top = '0';
        tempContainer.style.width = `${size}px`;
        tempContainer.style.height = `${size}px`;
        tempContainer.style.background = 'white';
        tempContainer.style.zIndex = '9999';
        document.body.appendChild(tempContainer);
        
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = size;
        tempCanvas.height = size;
        tempContainer.appendChild(tempCanvas);
        
        const tempChart = new Chart(tempCanvas, {
            type: chart.config.type,
            data: JSON.parse(JSON.stringify(chart.config.data)),
            options: {
                ...chart.config.options,
                responsive: false,
                maintainAspectRatio: false,
                animation: false
            }
        });
        
        setTimeout(() => {
            const chartDataURL = tempCanvas.toDataURL('image/png', 1.0);
            tempChart.destroy();
            document.body.removeChild(tempContainer);
            resolve(chartDataURL);
        }, 300);
    });
}

// Helper function to get chart ID from canvas (make sure this exists)
function getChartIdFromCanvas(canvas) {
    const chartIds = Object.keys(charts);
    for (const id of chartIds) {
        if (charts[id] && charts[id].canvas === canvas) {
            return id;
        }
    }
    return null;
}






// NEW CHART TRACKING - INITIALIZE ONCE
if (typeof activeCharts === 'undefined') {
    var activeCharts = {
    priority: true,    // Default charts on
    status: true,
    category: true,
    zone: true,
    trend: true,
    gauge: false,      // New charts off by default
    heatmap: false,
    comparison: false,
    units: false
};
}

function toggleChart(chartType) {
    activeCharts[chartType] = !activeCharts[chartType];
    updateCharts();
}

        // Global Data
        let allProblems = [];
        let filteredProblems = [];
        let currentDataset = 'all'; // 'all', 'current', or 'legacy'
let initialLoad = true;
        let activeFilters = {
            date: null,
            customDateRange: null,  // NEW: Custom date range {start, end}
            priorities: [],
            statuses: [],
            zones: [],
            categories: [],
            subCategories: [],
            assignedTo: [],  // NEW: Assigned to filter
            programmedOnly: false  // NEW: View ONLY programmed items
        };

        // Chart instances
        let charts = {};

        // API Configuration
        const API_URL = 'https://script.google.com/macros/s/AKfycbzEWNgrtuamJxLUEo_dWCm9-WxoD-zDejn6LKwV3Vt8yCHv0CArlBVtzj1ad_JM0A6N/exec';

        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            loadData();
        });

        // Toggle Slicer Section Collapse/Expand
        function toggleSlicerSection(header) {
            const content = header.nextElementSibling;
            const icon = header.querySelector('.expand-icon');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                header.classList.remove('collapsed');
            } else {
                content.classList.add('collapsed');
                header.classList.add('collapsed');
            }
        }

        // API Request Function
        async function makeRequest(action) {
            return new Promise((resolve, reject) => {
                const callbackName = 'callback_' + Math.random().toString(36).substr(2, 9);
                const script = document.createElement('script');
                const timeout = setTimeout(() => {
                    cleanup();
                    reject(new Error('Request timeout'));
                }, 30000);

                window[callbackName] = (data) => {
                    clearTimeout(timeout);
                    cleanup();
                    resolve(data);
                };

                function cleanup() {
                    delete window[callbackName];
                    if (script.parentNode) {
                        script.parentNode.removeChild(script);
                    }
                }

                script.src = API_URL + '?action=' + action + '&callback=' + callbackName;
                document.body.appendChild(script);
            });
        }

        // Load Data
        async function loadData() {
            try {
                document.getElementById('loadingOverlay').classList.remove('hidden');
                
                allProblems = [];
                
                // Load based on selected dataset
                if (currentDataset === 'current') {
                    const response = await makeRequest('getFaultLogData');
                    if (response && response.success) {
                        allProblems = response.data || [];
                    }
                } else if (currentDataset === 'legacy') {
                    const response = await makeRequest('getLegacyLogData');
                    if (response && response.success) {
                        allProblems = response.data || [];
                    }
                } else { // 'all' - load both
                    const [currentResponse, legacyResponse] = await Promise.all([
                        makeRequest('getFaultLogData'),
                        makeRequest('getLegacyLogData')
                    ]);
                    
                    if (currentResponse && currentResponse.success) {
                        allProblems = allProblems.concat(currentResponse.data || []);
                    }
                    if (legacyResponse && legacyResponse.success) {
                        allProblems = allProblems.concat(legacyResponse.data || []);
                    }
                }
                
                if (allProblems.length === 0) {
                    throw new Error('No data loaded');
                }
                
                filteredProblems = [...allProblems];

console.log(`‚úÖ Loaded ${allProblems.length} problems from ${currentDataset} dataset`);


                
// Set default to ALL FILTERS ACTIVE (only on initial load)
if (initialLoad && allProblems && allProblems.length > 0) {
    const allPriorities = [...new Set(allProblems.map(p => p.problemPriority).filter(p => p && p.trim() !== '' && p !== 'Not Set'))];
    const allStatuses = [...new Set(allProblems.map(p => p.problemStatus).filter(s => s && s.trim() !== '' && s !== 'Not Set'))];
    const allZones = [...new Set(allProblems.map(p => p.zone).filter(z => z && z.trim() !== '' && z !== 'Not Set'))];
    const allCategories = [...new Set(allProblems.map(p => p.category).filter(c => c && c.trim() !== '' && c !== 'Not Set'))];
    const allSubCategories = [...new Set(allProblems.map(p => p.subCategory).filter(sc => sc && sc.trim() !== '' && sc !== 'Not Set'))];
    const allAssignedTo = [...new Set(allProblems.map(p => p.assignedTo).filter(a => a && a.trim() !== '' && a !== 'Not Set'))];
    
    activeFilters = {
        date: 'all',
        customDateRange: null,
        priorities: allPriorities,
        statuses: allStatuses,
        zones: allZones,
        categories: allCategories,
        subCategories: allSubCategories,
        assignedTo: allAssignedTo,
        programmedOnly: false
    };
    
    // Set button to show it can clear filters
    const btn = document.getElementById('toggleAllBtn');
    btn.innerHTML = 'üóëÔ∏è CLEAR ALL FILTERS';
    btn.style.background = '#ef4444';
    
    initialLoad = false;  // ADD THIS LINE
}

buildSlicers();
updateDashboard();
buildSlicers();
updateDashboard();
                
                // Update badge
                const badgeText = currentDataset === 'current' ? 'üìä Live Data Only' : 
                                 currentDataset === 'legacy' ? 'üìö Historical Data (2023-2025)' : 
                                 'üîÑ Combined Dataset (All Years)';
                document.getElementById('datasetBadge').textContent = badgeText;
                
                document.getElementById('lastUpdated').textContent = 
                    `Last updated: ${new Date().toLocaleString('en-AU')}`;
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Failed to load dashboard data. Please refresh the page.');
            } finally {
                document.getElementById('loadingOverlay').classList.add('hidden');
            }
        }



       // Switch Dataset
        function switchDataset(dataset) {
            currentDataset = dataset;
            
            // Update button states
            document.getElementById('allDataBtn').classList.toggle('active', dataset === 'all');
            document.getElementById('currentDataBtn').classList.toggle('active', dataset === 'current');
            document.getElementById('legacyDataBtn').classList.toggle('active', dataset === 'legacy');
            
            // Reload data
            loadData();
        }

        // Parse Date Function
        function parseDate(dateString) {
            if (!dateString) return 0;
            try {
                if (dateString instanceof Date) return dateString.getTime();
                if (typeof dateString === 'string' && dateString.includes('/')) {
                    const parts = dateString.trim().split('/');
                    if (parts.length === 3) {
                        const month = parseInt(parts[0]) - 1;
                        const day = parseInt(parts[1]);
                        const year = parseInt(parts[2]);
                        if (day >= 1 && day <= 31 && month >= 0 && month <= 11 && year >= 1900) {
                            return new Date(year, month, day).getTime();
                        }
                    }
                }
                return new Date(dateString).getTime();
            } catch (error) { 
                return 0; 
            }
        }

        // Build Slicers
        function buildSlicers() {
            // Update Programmed count and appearance
            const programmedCount = allProblems.filter(p => 
                p.problemStatus === 'Programmed'
            ).length;
            document.getElementById('programmedCount').textContent = programmedCount;
            
            const programmedSlicer = document.getElementById('programmedSlicer');
            if (activeFilters.programmedOnly) {
                programmedSlicer.classList.add('active');
            } else {
                programmedSlicer.classList.remove('active');
            }

            // Date Range Slicers
            const dateRanges = [
                { label: 'Last 7 Days', value: '7d' },
                { label: 'Last 30 Days', value: '30d' },
                { label: 'Last 90 Days', value: '90d' },
                { label: 'Last 6 Months', value: '6m' },
                { label: 'This Year (2025)', value: 'year' },
                { label: 'All Time', value: 'all' }
            ];
            
            const dateHTML = dateRanges.map(range => 
                `<div class="slicer-item ${activeFilters.date === range.value ? 'active' : ''}" 
                      onclick="toggleDateFilter('${range.value}')">
                    ${range.label}
                </div>`
            ).join('');
            
            // Add year dropdown
            const years = [];
            for (let year = 2035; year >= 2020; year--) {
                years.push(year);
            }
            
            const yearDropdownHTML = `
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e2e8f0;">
                    <label style="font-size: 0.8rem; color: #64748b; font-weight: 600; margin-bottom: 6px; display: block;">Select Specific Year:</label>
                    <select id="yearDropdown" onchange="selectYear(this.value)" style="width: 100%; padding: 8px; border: 2px solid #e2e8f0; border-radius: 6px; font-size: 0.85rem; cursor: pointer;">
                        <option value="">Choose a year...</option>
                        ${years.map(year => `<option value="${year}">${year}</option>`).join('')}
                    </select>
                </div>
            `;
            
            document.getElementById('dateSlicers').innerHTML = dateHTML + yearDropdownHTML;

            // Priority Slicers - exclude empty/Not Set
            const priorities = {};
            allProblems.forEach(p => {
                const pri = p.problemPriority;
                if (pri && pri.trim() !== '' && pri !== 'Not Set') {
                    priorities[pri] = (priorities[pri] || 0) + 1;
                }
            });
            const priorityHTML = Object.entries(priorities).map(([priority, count]) => 
                `<div class="slicer-item ${activeFilters.priorities.includes(priority) ? 'active' : ''}" 
                      onclick="togglePriorityFilter('${priority}')">
                    <span>${priority}</span>
                    <span class="slicer-badge">${count}</span>
                </div>`
            ).join('');
            document.getElementById('prioritySlicers').innerHTML = priorityHTML;

            // Status Slicers - exclude empty/Not Set
            const statuses = {};
            allProblems.forEach(p => {
                const status = p.problemStatus;
                if (status && status.trim() !== '' && status !== 'Not Set') {
                    statuses[status] = (statuses[status] || 0) + 1;
                }
            });
            const statusHTML = Object.entries(statuses).map(([status, count]) => 
                `<div class="slicer-item ${activeFilters.statuses.includes(status) ? 'active' : ''}" 
                      onclick="toggleStatusFilter('${status}')">
                    <span>${status}</span>
                    <span class="slicer-badge">${count}</span>
                </div>`
            ).join('');
            document.getElementById('statusSlicers').innerHTML = statusHTML;

            // Zone Slicers - exclude empty/Not Set
            const zones = {};
            allProblems.forEach(p => {
                const zone = p.zone;
                if (zone && zone.trim() !== '' && zone !== 'Not Set') {
                    zones[zone] = (zones[zone] || 0) + 1;
                }
            });
            const zoneHTML = Object.entries(zones).map(([zone, count]) => 
                `<div class="slicer-item ${activeFilters.zones.includes(zone) ? 'active' : ''}" 
                      onclick="toggleZoneFilter('${zone}')">
                    <span>${zone}</span>
                    <span class="slicer-badge">${count}</span>
                </div>`
            ).join('');
            document.getElementById('zoneSlicers').innerHTML = zoneHTML;

            // Category Slicers - ALL categories, sorted alphabetically, exclude empty/Not Set
            const categories = {};
            allProblems.forEach(p => {
                const cat = p.category;
                // Only count if category exists and is not empty
                if (cat && cat.trim() !== '' && cat !== 'Not Set') {
                    categories[cat] = (categories[cat] || 0) + 1;
                }
            });
            
            const sortedCategories = Object.entries(categories)
                .sort((a, b) => a[0].localeCompare(b[0])); // Alphabetical order
            
            const categoryHTML = sortedCategories.map(([category, count]) => 
                `<div class="slicer-item ${activeFilters.categories.includes(category) ? 'active' : ''}" 
                      onclick="toggleCategoryFilter('${category.replace(/'/g, "\\'")}')">
                    <span>${category}</span>
                    <span class="slicer-badge">${count}</span>
                </div>`
            ).join('');
            document.getElementById('categorySlicers').innerHTML = categoryHTML || '<div style="padding: 10px; color: #94a3b8; font-size: 0.85rem;">No categories available</div>';

            // Sub-Category Slicers - ALL sub-categories, sorted alphabetically, exclude empty/Not Set
            const subCategories = {};
            allProblems.forEach(p => {
                const subCat = p.subCategory;
                // Only count if sub-category exists and is not empty
                if (subCat && subCat.trim() !== '' && subCat !== 'Not Set') {
                    subCategories[subCat] = (subCategories[subCat] || 0) + 1;
                }
            });
            
            const sortedSubCategories = Object.entries(subCategories)
                .sort((a, b) => a[0].localeCompare(b[0])); // Alphabetical order
            
            const subCategoryHTML = sortedSubCategories.map(([subCategory, count]) => 
                `<div class="slicer-item ${activeFilters.subCategories.includes(subCategory) ? 'active' : ''}" 
                      onclick="toggleSubCategoryFilter('${subCategory.replace(/'/g, "\\'")}')">
                    <span>${subCategory}</span>
                    <span class="slicer-badge">${count}</span>
                </div>`
            ).join('');
            document.getElementById('subCategorySlicers').innerHTML = subCategoryHTML || '<div style="padding: 10px; color: #94a3b8; font-size: 0.85rem;">No sub-categories available</div>';

            // Assigned To Slicers - exclude empty/Not Set
            const assignedTos = {};
            allProblems.forEach(p => {
                const assigned = p.assignedTo;
                if (assigned && assigned.trim() !== '' && assigned !== 'Not Set') {
                    assignedTos[assigned] = (assignedTos[assigned] || 0) + 1;
                }
            });
            
            const sortedAssignedTos = Object.entries(assignedTos)
                .sort((a, b) => a[0].localeCompare(b[0])); // Alphabetical order
            
            const assignedToHTML = sortedAssignedTos.map(([assigned, count]) => 
                `<div class="slicer-item ${activeFilters.assignedTo.includes(assigned) ? 'active' : ''}" 
                      onclick="toggleAssignedToFilter('${assigned.replace(/'/g, "\\'")}')">
                    <span>${assigned}</span>
                    <span class="slicer-badge">${count}</span>
                </div>`
            ).join('');
            document.getElementById('assignedToSlicers').innerHTML = assignedToHTML || '<div style="padding: 10px; color: #94a3b8; font-size: 0.85rem;">No assignments available</div>';
        }






        // Count by Field
        function countByField(field) {
            const counts = {};
            allProblems.forEach(p => {
                const value = p[field] || 'Not Set';
                counts[value] = (counts[value] || 0) + 1;
            });
            return counts;
        }

        // Toggle Filters
        function toggleDateFilter(value) {
            activeFilters.date = activeFilters.date === value ? null : value;
            // Clear year dropdown when using quick filters
            document.getElementById('yearDropdown').value = '';
            applyFilters();
        }

        function selectYear(year) {
            if (year) {
                activeFilters.date = year;
                applyFilters();
            }
        }

        function togglePriorityFilter(priority) {
            const index = activeFilters.priorities.indexOf(priority);
            if (index > -1) {
                activeFilters.priorities.splice(index, 1);
            } else {
                activeFilters.priorities.push(priority);
            }
            applyFilters();
        }

        function toggleStatusFilter(status) {
            const index = activeFilters.statuses.indexOf(status);
            if (index > -1) {
                activeFilters.statuses.splice(index, 1);
            } else {
                activeFilters.statuses.push(status);
            }
            applyFilters();
        }

        function toggleZoneFilter(zone) {
            const index = activeFilters.zones.indexOf(zone);
            if (index > -1) {
                activeFilters.zones.splice(index, 1);
            } else {
                activeFilters.zones.push(zone);
            }
            applyFilters();
        }

        function toggleCategoryFilter(category) {
            const index = activeFilters.categories.indexOf(category);
            if (index > -1) {
                activeFilters.categories.splice(index, 1);
            } else {
                activeFilters.categories.push(category);
            }
            applyFilters();
        }

        function toggleSubCategoryFilter(subCategory) {
            const index = activeFilters.subCategories.indexOf(subCategory);
            if (index > -1) {
                activeFilters.subCategories.splice(index, 1);
            } else {
                activeFilters.subCategories.push(subCategory);
            }
            applyFilters();
        }

        function toggleProgrammedOnlyFilter() {
            activeFilters.programmedOnly = !activeFilters.programmedOnly;
            applyFilters();
        }

        function toggleAssignedToFilter(assigned) {
            const index = activeFilters.assignedTo.indexOf(assigned);
            if (index > -1) {
                activeFilters.assignedTo.splice(index, 1);
            } else {
                activeFilters.assignedTo.push(assigned);
            }
            applyFilters();
        }

        function applyCustomDateRange() {
            const startInput = document.getElementById('customStartDate');
            const endInput = document.getElementById('customEndDate');
            
            if (!startInput.value || !endInput.value) {
                alert('Please select both start and end dates');
                return;
            }
            
            const startDate = new Date(startInput.value);
            const endDate = new Date(endInput.value);
            
            if (startDate > endDate) {
                alert('Start date must be before end date');
                return;
            }
            
            // Set custom date range
            activeFilters.customDateRange = { start: startDate, end: endDate };
            activeFilters.date = 'custom';  // Mark as custom
            
            applyFilters();
        }

        // Clear Filters
        function clearDateFilter() {
            activeFilters.date = null;
            applyFilters();
        }

        function clearPriorityFilter() {
            activeFilters.priorities = [];
            applyFilters();
        }

        function clearStatusFilter() {
            activeFilters.statuses = [];
            applyFilters();
        }

        function clearZoneFilter() {
            activeFilters.zones = [];
            applyFilters();
        }

        function clearCategoryFilter() {
            activeFilters.categories = [];
            applyFilters();
        }

        function clearSubCategoryFilter() {
            activeFilters.subCategories = [];
            applyFilters();
        }

        function clearAssignedToFilter() {
            activeFilters.assignedTo = [];
            applyFilters();
        }

        function clearDateFilter() {
            activeFilters.date = null;
            activeFilters.customDateRange = null;
            document.getElementById('customStartDate').value = '';
            document.getElementById('customEndDate').value = '';
            document.getElementById('yearDropdown').value = '';
            applyFilters();
        }



        function toggleAllFilters() {
    const hasActiveFilters = activeFilters.date || 
                            activeFilters.customDateRange ||
                            activeFilters.priorities.length > 0 || 
                            activeFilters.statuses.length > 0 || 
                            activeFilters.zones.length > 0 || 
                            activeFilters.categories.length > 0 ||
                            activeFilters.subCategories.length > 0 ||
                            activeFilters.assignedTo.length > 0 ||
                            activeFilters.programmedOnly;
    
    const btn = document.getElementById('toggleAllBtn');
    
    if (hasActiveFilters) {
        // CLEAR ALL FILTERS (show nothing)
        activeFilters = {
            date: null,
            customDateRange: null,
            priorities: [],
            statuses: [],
            zones: [],
            categories: [],
            subCategories: [],
            assignedTo: [],
            programmedOnly: false
        };
        document.getElementById('customStartDate').value = '';
        document.getElementById('customEndDate').value = '';
        document.getElementById('yearDropdown').value = '';
        btn.innerHTML = '‚úÖ SELECT ALL FILTERS';
        btn.style.background = '#10b981';
    } else {
        // SELECT ALL FILTERS (show everything except programmed by default)
        activeFilters.date = 'all';
        
        // Get all available values for each filter (exclude empty/Not Set)
        const priorities = [...new Set(allProblems.map(p => p.problemPriority).filter(p => p && p.trim() !== '' && p !== 'Not Set'))];
        const statuses = [...new Set(allProblems.map(p => p.problemStatus).filter(s => s && s.trim() !== '' && s !== 'Not Set'))];
        const zones = [...new Set(allProblems.map(p => p.zone).filter(z => z && z.trim() !== '' && z !== 'Not Set'))];
        const categories = [...new Set(allProblems.map(p => p.category).filter(c => c && c.trim() !== '' && c !== 'Not Set'))];
        const subCategories = [...new Set(allProblems.map(p => p.subCategory).filter(sc => sc && sc.trim() !== '' && sc !== 'Not Set'))];
        const assignedTos = [...new Set(allProblems.map(p => p.assignedTo).filter(a => a && a.trim() !== '' && a !== 'Not Set'))];
        
        activeFilters.priorities = priorities;
        activeFilters.statuses = statuses;
        activeFilters.zones = zones;
        activeFilters.categories = categories;
        activeFilters.subCategories = subCategories;
        activeFilters.assignedTo = assignedTos;
        activeFilters.programmedOnly = false; // Don't include programmed by default
        
        btn.innerHTML = 'üóëÔ∏è CLEAR ALL FILTERS';
        btn.style.background = '#ef4444';
    }
    
    applyFilters();
}



        // Apply Filters
function applyFilters() {
    // Start with ALL problems
    filteredProblems = [...allProblems];

    // Apply programmed filter FIRST (if active)
    if (activeFilters.programmedOnly) {
        filteredProblems = filteredProblems.filter(p => 
            p.problemStatus === 'Programmed'
        );
    }
    // If no filters are active at all, show NOTHING (except when programmedOnly is active)
    else if (!activeFilters.programmedOnly && 
             !activeFilters.date && 
             !activeFilters.customDateRange &&
             activeFilters.priorities.length === 0 && 
             activeFilters.statuses.length === 0 && 
             activeFilters.zones.length === 0 && 
             activeFilters.categories.length === 0 &&
             activeFilters.subCategories.length === 0 &&
             activeFilters.assignedTo.length === 0) {
        filteredProblems = [];
    }

    // Date filter
    if (activeFilters.customDateRange) {
        // Custom date range takes priority
        const startTime = activeFilters.customDateRange.start.getTime();
        const endTime = activeFilters.customDateRange.end.getTime();
        
        filteredProblems = filteredProblems.filter(p => {
            const problemDate = parseDate(p.timestamp);
            return problemDate >= startTime && problemDate <= endTime;
        });
    } else if (activeFilters.date) {
        const now = new Date();
        let startDate, endDate;

        switch(activeFilters.date) {
            case '7d':
                startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);
                endDate = now;
                break;
            case '30d':
                startDate = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
                endDate = now;
                break;
            case '90d':
                startDate = new Date(now.getFullYear(), now.getMonth() - 3, now.getDate());
                endDate = now;
                break;
            case '6m':
                startDate = new Date(now.getFullYear(), now.getMonth() - 6, now.getDate());
                endDate = now;
                break;
            case 'year':
                startDate = new Date(now.getFullYear(), 0, 1);
                endDate = now;
                break;
            case '2020':
            case '2021':
            case '2022':
            case '2023':
            case '2024':
            case '2025':
            case '2026':
            case '2027':
            case '2028':
            case '2029':
            case '2030':
            case '2031':
            case '2032':
            case '2033':
            case '2034':
            case '2035':
                const year = parseInt(activeFilters.date);
                startDate = new Date(year, 0, 1);
                endDate = new Date(year, 11, 31);
                break;
            case 'all':
            default:
                startDate = null;
                endDate = null;
        }

        if (startDate && endDate) {
            filteredProblems = filteredProblems.filter(p => {
                const problemDate = parseDate(p.timestamp);
                return problemDate >= startDate.getTime() && problemDate <= endDate.getTime();
            });
        }
    }

    // Check if any category filters are active
    const hasAnyFilters = activeFilters.priorities.length > 0 || 
                         activeFilters.statuses.length > 0 || 
                         activeFilters.zones.length > 0 || 
                         activeFilters.categories.length > 0 ||
                         activeFilters.subCategories.length > 0 ||
                         activeFilters.assignedTo.length > 0;

    // If no category filters active (and not programmed-only mode), show nothing
    if (!hasAnyFilters && !activeFilters.programmedOnly) {
        filteredProblems = [];
    } else if (!activeFilters.programmedOnly) {
        // Apply OR logic - filter to show problems that match ANY selected filter
        filteredProblems = filteredProblems.filter(problem => {
            let matchesAnyFilter = false;

            // Check Priority filter
            if (activeFilters.priorities.length > 0) {
                if (activeFilters.priorities.includes(problem.problemPriority)) {
                    matchesAnyFilter = true;
                }
            }

            // Check Status filter
            if (activeFilters.statuses.length > 0) {
                if (activeFilters.statuses.includes(problem.problemStatus)) {
                    matchesAnyFilter = true;
                }
            }

            // Check Zone filter
            if (activeFilters.zones.length > 0) {
                if (activeFilters.zones.includes(problem.zone)) {
                    matchesAnyFilter = true;
                }
            }

            // Check Category filter
            if (activeFilters.categories.length > 0) {
                if (activeFilters.categories.includes(problem.category)) {
                    matchesAnyFilter = true;
                }
            }

            // Check Sub-Category filter
            if (activeFilters.subCategories.length > 0) {
                if (activeFilters.subCategories.includes(problem.subCategory)) {
                    matchesAnyFilter = true;
                }
            }

            // Check Assigned To filter
            if (activeFilters.assignedTo.length > 0) {
                if (activeFilters.assignedTo.includes(problem.assignedTo)) {
                    matchesAnyFilter = true;
                }
            }

            return matchesAnyFilter;
        });
    }

    buildSlicers();
    updateDashboard();
    updateFilterSummary();
}

        // Update Filter Summary
function updateFilterSummary() {
    const hasFilters = activeFilters.date || 
                       activeFilters.customDateRange ||
                       activeFilters.priorities.length > 0 || 
                       activeFilters.statuses.length > 0 || 
                       activeFilters.zones.length > 0 || 
                       activeFilters.categories.length > 0 ||
                       activeFilters.subCategories.length > 0 ||
                       activeFilters.assignedTo.length > 0 ||
                       activeFilters.programmedOnly;

    const summaryDiv = document.getElementById('filterSummary');
    
    // Check if we have NO filters and NO results (empty state)
    const noFiltersAndNoResults = !hasFilters && filteredProblems.length === 0;
    
    if (!hasFilters && !noFiltersAndNoResults) {
        summaryDiv.classList.add('hidden');
        return;
    }

    summaryDiv.classList.remove('hidden');
    
    let tags = [];
    
    // Show "No Filters" warning when nothing is selected and no results
    if (noFiltersAndNoResults) {
        tags.push('‚ö†Ô∏è No filters selected - showing no results');
    }
    
    if (activeFilters.programmedOnly) {
        tags.push('üîß Programmed Only');
    }
    
    if (activeFilters.customDateRange) {
        const start = activeFilters.customDateRange.start.toLocaleDateString('en-AU');
        const end = activeFilters.customDateRange.end.toLocaleDateString('en-AU');
        tags.push(`üìÖ ${start} to ${end}`);
    } else if (activeFilters.date) {
        const dateLabels = {
            '7d': 'Last 7 Days',
            '30d': 'Last 30 Days',
            '90d': 'Last 90 Days',
            '6m': 'Last 6 Months',
            'year': 'This Year',
            'all': 'All Time',
            '2020': 'Year 2020',
            '2021': 'Year 2021',
            '2022': 'Year 2022',
            '2023': 'Year 2023',
            '2024': 'Year 2024',
            '2025': 'Year 2025',
            '2026': 'Year 2026',
            '2027': 'Year 2027',
            '2028': 'Year 2028',
            '2029': 'Year 2029',
            '2030': 'Year 2030',
            '2031': 'Year 2031',
            '2032': 'Year 2032',
            '2033': 'Year 2033',
            '2034': 'Year 2034',
            '2035': 'Year 2035'
        };
        tags.push(`üìÖ ${dateLabels[activeFilters.date] || activeFilters.date}`);
    }

    activeFilters.priorities.forEach(p => tags.push(`üö® ${p}`));
    activeFilters.statuses.forEach(s => tags.push(`üìä ${s}`));
    activeFilters.zones.forEach(z => tags.push(`üó∫Ô∏è ${z}`));
    activeFilters.categories.forEach(c => tags.push(`üìÅ ${c}`));
    activeFilters.subCategories.forEach(sc => tags.push(`üìÇ ${sc}`));
    activeFilters.assignedTo.forEach(a => tags.push(`üë∑ ${a}`));

    document.getElementById('filterTags').innerHTML = tags
        .map(tag => `<span class="filter-tag">${tag}</span>`)
        .join('');
}

        // Update Dashboard
        function updateDashboard() {
            updateKPIs();
            updateCharts();
        }




        function updateKPIs() {
    // Filter out programmed items by default unless specifically filtered for
    let displayProblems = filteredProblems;
    if (!activeFilters.programmedOnly) {
        displayProblems = filteredProblems.filter(p => p.problemStatus !== 'Programmed');
    }
    
    const total = displayProblems.length;
    const active = displayProblems.filter(p => 
        !['Completed', 'Cancelled', 'Programmed'].includes(p.problemStatus)
    ).length;
    const urgent = displayProblems.filter(p => 
        ['Urgent', 'High'].includes(p.problemPriority)
    ).length;
    const completed = displayProblems.filter(p => 
        p.problemStatus === 'Completed'
    ).length;
    const completionRate = total > 0 ? Math.round((completed / total) * 100) : 0;

    // Calculate average resolution time (exclude programmed and on-hold)
    const completedProblems = displayProblems.filter(p => 
        p.problemStatus === 'Completed' && p.completionDate && p.timestamp
    );
    
    let avgDays = 0;
    if (completedProblems.length > 0) {
        let totalDays = 0;
        let validCount = 0;
        
        completedProblems.forEach(p => {
            const start = parseDate(p.timestamp);
            const end = parseDate(p.completionDate);
            if (start && end && end > start) {
                const days = Math.round((end - start) / (1000 * 60 * 60 * 24));
                if (days >= 0) {
                    totalDays += days === 0 ? 1 : days;
                    validCount++;
                }
            }
        });
        
        avgDays = validCount > 0 ? Math.round(totalDays / validCount) : 0;
    }

    // This week (exclude programmed)
    const oneWeekAgo = new Date().getTime() - (7 * 24 * 60 * 60 * 1000);
    const thisWeek = displayProblems.filter(p => {
        const problemDate = parseDate(p.timestamp);
        return problemDate >= oneWeekAgo;
    }).length;

    // KPI HTML - Match Desktop Module style
    const kpis = [
        {
            label: 'Total Problems',
            value: total,
            sublabel: activeFilters.programmedOnly ? 'Programmed items only' : 'Excluding programmed items',
            class: 'default'
        },
        {
            label: 'Active Issues',
            value: active,
            sublabel: `${Math.round((active/total)*100)}% of total`,
            class: active > total * 0.5 ? 'warning' : 'success'
        },
        {
            label: 'Urgent/High Priority',
            value: urgent,
            sublabel: `${Math.round((urgent/total)*100)}% need attention`,
            class: urgent > 0 ? 'danger' : 'success'
        },
        {
            label: 'Completion Rate',
            value: completionRate + '%',
            sublabel: `${completed} of ${total} complete`,
            class: completionRate >= 75 ? 'success' : completionRate >= 50 ? 'warning' : 'danger'
        }
        // Removed Avg Resolution Time as requested
    ];

    const kpiHTML = kpis.map(kpi => `
        <div class="kpi-card ${kpi.class}">
            <div class="kpi-label">${kpi.label}</div>
            <div class="kpi-value">${kpi.value}</div>
            <div class="kpi-sublabel">${kpi.sublabel}</div>
        </div>
    `).join('');

    document.getElementById('kpiGrid').innerHTML = kpiHTML;
}





// GAUGE CHART
function createGaugeChart() {
    if (!activeCharts.gauge) return;
    
    const total = filteredProblems.length;
    const completed = filteredProblems.filter(p => p.problemStatus === 'Completed').length;
    const rate = total > 0 ? Math.round((completed / total) * 100) : 0;

    const chartCard = document.createElement('div');
    chartCard.className = 'chart-card';
    chartCard.innerHTML = `
        <div class="chart-header">
            <h3>‚è±Ô∏è Completion Rate Gauge</h3>
            <button onclick="exportChart('gaugeChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="gaugeChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(chartCard);

    const ctx = document.getElementById('gaugeChart');
    charts.gauge = new Chart(ctx, {
        type: 'doughnut',
        data: {
            datasets: [{
                data: [rate, 100 - rate],
                backgroundColor: [
                    rate >= 75 ? '#10b981' : rate >= 50 ? '#f59e0b' : '#ef4444',
                    document.body.getAttribute('data-theme') === 'dark' ? '#374151' : '#e5e7eb'
                ],
                borderWidth: 0,
                circumference: 180,
                rotation: 270,
                cutout: '75%'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } }
        },
        plugins: [{
            afterDraw: function(chart) {
                const ctx = chart.ctx;
                const centerX = chart.width / 2;
                const centerY = chart.height / 2 + 30;
                
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = document.body.getAttribute('data-theme') === 'dark' ? '#f1f5f9' : '#1e293b';
                ctx.font = 'bold 3rem sans-serif';
                ctx.fillText(`${rate}%`, centerX, centerY);
                
                ctx.font = 'bold 1.2rem sans-serif';
                ctx.fillStyle = document.body.getAttribute('data-theme') === 'dark' ? '#cbd5e1' : '#64748b';
                ctx.fillText('Completion Rate', centerX, centerY + 40);
                ctx.restore();
            }
        }]
    });
}

// HEATMAP CHART
function createHeatmapChart() {
    if (!activeCharts.heatmap) return;
    
    const chartCard = document.createElement('div');
    chartCard.className = 'chart-card full-width';
    chartCard.innerHTML = `
        <div class="chart-header">
            <h3>üî• Monthly Problem Heatmap</h3>
            <button onclick="exportChart('heatmapChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="heatmapChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(chartCard);

    const heatmapData = {};
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const priorities = ['Low', 'Medium', 'High', 'Urgent'];
    
    months.forEach(month => {
        heatmapData[month] = {};
        priorities.forEach(priority => {
            heatmapData[month][priority] = 0;
        });
    });
    
    filteredProblems.forEach(p => {
        const date = parseDate(p.timestamp);
        if (date) {
            const month = new Date(date).toLocaleDateString('en-US', { month: 'short' });
            const priority = p.problemPriority || 'Low';
            if (heatmapData[month] && heatmapData[month][priority] !== undefined) {
                heatmapData[month][priority]++;
            }
        }
    });

    const datasets = priorities.map((priority, index) => ({
        label: priority,
        data: months.map(month => heatmapData[month][priority]),
        backgroundColor: ['rgba(16, 185, 129, 0.8)', 'rgba(245, 158, 11, 0.8)', 'rgba(239, 68, 68, 0.8)', 'rgba(220, 38, 38, 0.9)'][index],
        borderWidth: 2,
        borderRadius: 6
    }));

    const ctx = document.getElementById('heatmapChart');
    charts.heatmap = new Chart(ctx, {
        type: 'bar',
        data: { labels: months, datasets: datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { stacked: true },
                y: { stacked: true, beginAtZero: true, ticks: { stepSize: 1 } }
            },
            plugins: { legend: { position: 'top' } }
        }
    });
}

// COMPARISON CHART  
function createComparisonChart() {
    if (!activeCharts.comparison) return;
    
    const chartCard = document.createElement('div');
    chartCard.className = 'chart-card full-width';
    chartCard.innerHTML = `
        <div class="chart-header">
            <h3>üìä Year-over-Year Comparison</h3>
            <button onclick="exportChart('comparisonChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="comparisonChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(chartCard);

    const currentYear = new Date().getFullYear();
    const lastYear = currentYear - 1;
    
    const yearData = {
        [currentYear]: { total: 0, completed: 0, urgent: 0 },
        [lastYear]: { total: 0, completed: 0, urgent: 0 }
    };
    
    filteredProblems.forEach(p => {
        const date = parseDate(p.timestamp);
        if (date) {
            const year = new Date(date).getFullYear();
            if (yearData[year]) {
                yearData[year].total++;
                if (p.problemStatus === 'Completed') yearData[year].completed++;
                if (['Urgent', 'High'].includes(p.problemPriority)) yearData[year].urgent++;
            }
        }
    });

    const ctx = document.getElementById('comparisonChart');
    charts.comparison = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Total Problems', 'Completed', 'Urgent/High'],
            datasets: [
                {
                    label: `${lastYear}`,
                    data: [yearData[lastYear].total, yearData[lastYear].completed, yearData[lastYear].urgent],
                    backgroundColor: 'rgba(107, 114, 128, 0.8)',
                    borderRadius: 6
                },
                {
                    label: `${currentYear}`,
                    data: [yearData[currentYear].total, yearData[currentYear].completed, yearData[currentYear].urgent],
                    backgroundColor: 'rgba(59, 130, 246, 0.8)',
                    borderRadius: 6
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { position: 'top' } },
            scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } }
        }
    });
}


        // Update Charts

   function updateCharts() {
    // Clear all existing chart containers
    const chartGrid = document.getElementById('chartGrid');
    chartGrid.innerHTML = '';
    
    // Destroy all existing charts
    Object.values(charts).forEach(chart => {
        if (chart && chart.destroy) chart.destroy();
    });
    charts = {};
    
    // Create only active charts
    if (activeCharts.priority) updatePriorityChart();
    if (activeCharts.status) updateStatusChart();
    if (activeCharts.category) updateCategoryChart();
    if (activeCharts.zone) updateZoneChart();
    if (activeCharts.trend) updateTrendChart();
    if (activeCharts.gauge) updateGaugeChart();
    if (activeCharts.heatmap) updateHeatmapChart();
    if (activeCharts.comparison) updateComparisonChart();
    if (activeCharts.units) updateTop10UnitsChart();
}


        function updatePriorityChart() {
    const container = document.createElement('div');
    container.className = 'chart-card';
    container.id = 'priorityChartContainer';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üö® Priority Distribution</h3>
            <button onclick="exportChart('priorityChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="priorityChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(container);

    const priorities = {};
    filteredProblems.forEach(p => {
        const priority = p.problemPriority || 'Not Set';
        priorities[priority] = (priorities[priority] || 0) + 1;
    });

    const ctx = document.getElementById('priorityChart');
    charts.priority = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: Object.keys(priorities),
            datasets: [{
                data: Object.values(priorities),
                backgroundColor: Object.keys(priorities).map(priority => {
                    switch(priority.toLowerCase()) {
                        case 'urgent': return '#fecaca';
                        case 'high': return '#fed7aa';
                        case 'medium': return '#fde68a';
                        case 'low': return '#d1fae5';
                        default: return '#e5e7eb';
                    }
                })
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' },
                title: { display: true, text: `${filteredProblems.length} problems analyzed` }
            }
        }
    });
}

        function updateStatusChart() {
    const container = document.createElement('div');
    container.className = 'chart-card';
    container.id = 'statusChartContainer';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üìä Status Pipeline</h3>
            <button onclick="exportChart('statusChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="statusChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(container);

    const statuses = {};
    filteredProblems.forEach(p => {
        const status = p.problemStatus || 'Not Set';
        statuses[status] = (statuses[status] || 0) + 1;
    });

    const ctx = document.getElementById('statusChart');
    charts.status = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: Object.keys(statuses),
            datasets: [{
                label: 'Problems',
                data: Object.values(statuses),
                backgroundColor: '#3b82f6',
                borderRadius: 6
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: { display: true, text: `${filteredProblems.length} problems by status` }
            },
            scales: {
                y: { beginAtZero: true, ticks: { stepSize: 1 } }
            }
        }
    });
}

        function updateCategoryChart() {
    const container = document.createElement('div');
    container.className = 'chart-card';
    container.id = 'categoryChartContainer';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üìÅ Top 10 Categories</h3>
            <button onclick="exportChart('categoryChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="categoryChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(container);

    const categories = {};
    filteredProblems.forEach(p => {
        const category = p.category;
        if (category && category.trim() !== '' && category !== 'Not Set') {
            categories[category] = (categories[category] || 0) + 1;
        }
    });

    const sortedCategories = Object.entries(categories)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    const ctx = document.getElementById('categoryChart');
    charts.category = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedCategories.map(c => c[0]),
            datasets: [{
                label: 'Problems',
                data: sortedCategories.map(c => c[1]),
                backgroundColor: '#f59e0b',
                borderRadius: 6
            }]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: { display: true, text: `Top categories from ${filteredProblems.length} problems` }
            },
            scales: {
                x: { beginAtZero: true, ticks: { stepSize: 1 } }
            }
        }
    });
}

        function updateZoneChart() {
    const container = document.createElement('div');
    container.className = 'chart-card';
    container.id = 'zoneChartContainer';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üó∫Ô∏è Zone Distribution</h3>
            <button onclick="exportChart('zoneChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="zoneChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(container);

    const zones = {};
    filteredProblems.forEach(p => {
        const zone = p.zone || 'Not Set';
        zones[zone] = (zones[zone] || 0) + 1;
    });

    const ctx = document.getElementById('zoneChart');
    charts.zone = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: Object.keys(zones),
            datasets: [{
                label: 'Problems',
                data: Object.values(zones),
                backgroundColor: '#8b5cf6',
                borderRadius: 6
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: { display: true, text: `${filteredProblems.length} problems by zone` }
            },
            scales: {
                y: { beginAtZero: true, ticks: { stepSize: 1 } }
            }
        }
    });
}

        function updateTrendChart() {
    const container = document.createElement('div');
    container.className = 'chart-card full-width';
    container.id = 'trendChartContainer';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üìà 6-Month Trend Analysis</h3>
            <button onclick="exportChart('trendChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container" style="height: 350px;">
            <canvas id="trendChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(container);

    const monthlyData = {};
    const now = new Date();
    const months = [];
    
    for (let i = 5; i >= 0; i--) {
        const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
        const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
        months.push({
            key: key,
            label: d.toLocaleDateString('en-AU', { month: 'short', year: 'numeric' }),
            value: 0
        });
        monthlyData[key] = 0;
    }
    
    filteredProblems.forEach(p => {
        const timestamp = parseDate(p.timestamp);
        if (timestamp) {
            const date = new Date(timestamp);
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            if (monthlyData.hasOwnProperty(monthKey)) {
                monthlyData[monthKey]++;
            }
        }
    });

    months.forEach(month => {
        month.value = monthlyData[month.key];
    });

    const ctx = document.getElementById('trendChart');
    charts.trend = new Chart(ctx, {
        type: 'line',
        data: {
            labels: months.map(m => m.label),
            datasets: [{
                label: 'Problems Reported',
                data: months.map(m => m.value),
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                tension: 0.4,
                fill: true,
                borderWidth: 3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: { display: true, text: `${filteredProblems.length} problems over 6 months` }
            },
            scales: {
                y: { beginAtZero: true, ticks: { stepSize: 1 } }
            }
        }
    });
}

function updateGaugeChart() {
    const total = filteredProblems.length;
    const completed = filteredProblems.filter(p => p.problemStatus === 'Completed').length;
    const rate = total > 0 ? Math.round((completed / total) * 100) : 0;

    // Remove existing container if it exists
    let container = document.getElementById('gaugeChartContainer');
    if (container) container.remove();

    // Create new container
    container = document.createElement('div');
    container.id = 'gaugeChartContainer';
    container.className = 'chart-card';
    container.innerHTML = `
        <div class="chart-header">
            <h3>‚è±Ô∏è Completion Rate Gauge</h3>
            <button onclick="exportChart('gaugeChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="gaugeChart"></canvas>
        </div>
    `;
    document.getElementById('chartGrid').appendChild(container);

    if (charts.gauge) charts.gauge.destroy();

    const ctx = document.getElementById('gaugeChart');
    charts.gauge = new Chart(ctx, {
        type: 'doughnut',
        data: {
            datasets: [{
                data: [rate, 100 - rate],
                backgroundColor: [
                    rate >= 75 ? '#10b981' : rate >= 50 ? '#f59e0b' : '#ef4444',
                    '#e5e7eb'
                ],
                borderWidth: 0,
                circumference: 180,
                rotation: 270,
                cutout: '75%'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { display: false } }
        },
        plugins: [{
            afterDraw: function(chart) {
                const ctx = chart.ctx;
                const centerX = chart.width / 2;
                const centerY = chart.height / 2 + 30;
                
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#1e293b';
                ctx.font = 'bold 3rem sans-serif';
                ctx.fillText(`${rate}%`, centerX, centerY);
                
                ctx.font = 'bold 1.2rem sans-serif';
                ctx.fillStyle = '#64748b';
                ctx.fillText('Completion Rate', centerX, centerY + 40);
                ctx.restore();
            }
        }]
    });
}

function updateHeatmapChart() {
    if (!activeCharts.heatmap) return;
    
    // Remove existing container
    let container = document.getElementById('heatmapChartContainer');
    if (container) container.remove();

    // Get the active year from filters or default to current year
    let targetYear = new Date().getFullYear();
    
    // Check if a specific year is selected in filters
    if (activeFilters.date && activeFilters.date.match(/^\d{4}$/)) {
        targetYear = parseInt(activeFilters.date);
    }

    container = document.createElement('div');
    container.id = 'heatmapChartContainer';
    container.className = 'chart-card full-width';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üî• ${targetYear} Monthly Problem Heatmap</h3>
            <button onclick="exportChart('heatmapChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="heatmapChart"></canvas>
        </div>
    `;
    document.querySelector('.chart-grid').appendChild(container);

    const heatmapData = {};
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const priorities = ['Low', 'Medium', 'High', 'Urgent'];
    
    // Initialize data structure
    months.forEach(month => {
        heatmapData[month] = {};
        priorities.forEach(priority => {
            heatmapData[month][priority] = 0;
        });
    });
    
    // Filter problems for the specific year
    const yearProblems = filteredProblems.filter(p => {
        const date = parseDate(p.timestamp);
        if (date) {
            const year = new Date(date).getFullYear();
            return year === targetYear;
        }
        return false;
    });
    
    // Count problems by month and priority for the target year
    yearProblems.forEach(p => {
        const date = parseDate(p.timestamp);
        if (date) {
            const month = new Date(date).toLocaleDateString('en-US', { month: 'short' });
            const priority = p.problemPriority || 'Low';
            if (heatmapData[month] && heatmapData[month][priority] !== undefined) {
                heatmapData[month][priority]++;
            }
        }
    });

    const datasets = priorities.map((priority, index) => ({
        label: priority,
        data: months.map(month => heatmapData[month][priority]),
        backgroundColor: ['rgba(16, 185, 129, 0.8)', 'rgba(245, 158, 11, 0.8)', 'rgba(239, 68, 68, 0.8)', 'rgba(220, 38, 38, 0.9)'][index],
        borderWidth: 2,
        borderRadius: 6
    }));

    if (charts.heatmap) charts.heatmap.destroy();

    const ctx = document.getElementById('heatmapChart');
    charts.heatmap = new Chart(ctx, {
        type: 'bar',
        data: { labels: months, datasets: datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: { stacked: true },
                y: { stacked: true, beginAtZero: true, ticks: { stepSize: 1 } }
            },
            plugins: { 
                legend: { position: 'top' },
                title: { 
                    display: true, 
                    text: `${yearProblems.length} problems reported in ${targetYear}` 
                }
            }
        }
    });
}

function updateComparisonChart() {
    if (!activeCharts.comparison) return;
    
    let container = document.getElementById('comparisonChartContainer');
    if (container) container.remove();

    // Determine which years to compare based on available data
    const yearCounts = {};
    filteredProblems.forEach(p => {
        const date = parseDate(p.timestamp);
        if (date) {
            const year = new Date(date).getFullYear();
            yearCounts[year] = (yearCounts[year] || 0) + 1;
        }
    });

    // Get the two most recent years with data
    const availableYears = Object.keys(yearCounts).map(y => parseInt(y)).sort((a, b) => b - a);
    const year1 = availableYears[0] || new Date().getFullYear();
    const year2 = availableYears[1] || year1 - 1;

    container = document.createElement('div');
    container.id = 'comparisonChartContainer';
    container.className = 'chart-card full-width';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üìä ${year2} vs ${year1} Comparison</h3>
            <button onclick="exportChart('comparisonChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="comparisonChart"></canvas>
        </div>
    `;
    document.querySelector('.chart-grid').appendChild(container);

    const yearData = {
        [year1]: { total: 0, completed: 0, urgent: 0 },
        [year2]: { total: 0, completed: 0, urgent: 0 }
    };
    
    filteredProblems.forEach(p => {
        const date = parseDate(p.timestamp);
        if (date) {
            const year = new Date(date).getFullYear();
            if (yearData[year]) {
                yearData[year].total++;
                if (p.problemStatus === 'Completed') yearData[year].completed++;
                if (['Urgent', 'High'].includes(p.problemPriority)) yearData[year].urgent++;
            }
        }
    });

    if (charts.comparison) charts.comparison.destroy();

    const ctx = document.getElementById('comparisonChart');
    charts.comparison = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['Total Problems', 'Completed', 'Urgent/High Priority'],
            datasets: [
                {
                    label: `${year2}`,
                    data: [yearData[year2].total, yearData[year2].completed, yearData[year2].urgent],
                    backgroundColor: 'rgba(107, 114, 128, 0.8)',
                    borderRadius: 6
                },
                {
                    label: `${year1}`,
                    data: [yearData[year1].total, yearData[year1].completed, yearData[year1].urgent],
                    backgroundColor: 'rgba(59, 130, 246, 0.8)',
                    borderRadius: 6
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
                legend: { position: 'top' },
                title: { 
                    display: true, 
                    text: `Available years: ${availableYears.join(', ')}` 
                }
            },
            scales: { y: { beginAtZero: true, ticks: { stepSize: 1 } } }
        }
    });
}

function updateTop10UnitsChart() {
    if (!activeCharts.units) return;
    
    let container = document.getElementById('unitsChartContainer');
    if (container) container.remove();

    // Count problems by unitNumber (the correct field name)
    const unitCounts = {};
    filteredProblems.forEach(p => {
        const unit = p.unitNumber;  // Using the correct field name
        if (unit && unit.toString().trim() !== '' && unit !== 'Not Set') {
            const unitKey = unit.toString();
            unitCounts[unitKey] = (unitCounts[unitKey] || 0) + 1;
        }
    });

    // Get top 10 units
    const sortedUnits = Object.entries(unitCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);

    container = document.createElement('div');
    container.id = 'unitsChartContainer';
    container.className = 'chart-card';
    container.innerHTML = `
        <div class="chart-header">
            <h3>üè† Top 10 Most Reported Units</h3>
            <button onclick="exportChart('unitsChart')" style="background: #3b82f6; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">üì§ Export</button>
        </div>
        <div class="chart-container">
            <canvas id="unitsChart"></canvas>
        </div>
    `;
    document.querySelector('.chart-grid').appendChild(container);

    if (charts.units) charts.units.destroy();

    const ctx = document.getElementById('unitsChart');
    charts.units = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedUnits.map(u => u[0]),
            datasets: [{
                label: 'Problems Reported',
                data: sortedUnits.map(u => u[1]),
                backgroundColor: '#e11d48',
                borderRadius: 6
            }]
        },
        options: {
            indexAxis: 'y', // Horizontal bars
            responsive: true,
            maintainAspectRatio: false,
            plugins: { 
                legend: { display: false },
                title: { 
                    display: true, 
                    text: `Based on ${filteredProblems.length} problems` 
                }
            },
            scales: {
                x: { beginAtZero: true, ticks: { stepSize: 1 } }
            }
        }
    });
}



// EXPORT FUNCTIONS


async function exportPNG() {
    try {
        const dashboard = document.querySelector('.dashboard-container');
        const canvas = await html2canvas(dashboard, {
            scale: 1.2,
            useCORS: true,
            backgroundColor: document.body.getAttribute('data-theme') === 'dark' ? '#0f172a' : '#ffffff'
        });
        
        const link = document.createElement('a');
        link.download = `lake-illawong-dashboard-${new Date().toISOString().split('T')[0]}.png`;
        link.href = canvas.toDataURL();
        link.click();
        
        alert('‚úÖ PNG exported successfully!');
        
    } catch (error) {
        console.error('PNG export error:', error);
        alert('Error exporting PNG. Please try again.');
    }
}

function exportCSV() {
    const csvData = filteredProblems.map(p => ({
        'Problem ID': p.problemId || '',
        'Timestamp': p.timestamp || '',
        'Unit': p.unit || '',
        'Zone': p.zone || '',
        'Category': p.category || '',
        'Priority': p.problemPriority || '',
        'Status': p.problemStatus || '',
        'Description': (p.description || '').replace(/"/g, '""'),
        'Assigned To': p.assignedTo || '',
        'Source': p.source || ''
    }));
    
    if (csvData.length === 0) {
        alert('No data to export');
        return;
    }
    
    const headers = Object.keys(csvData[0]);
    const csvContent = [
        headers.join(','),
        ...csvData.map(row => 
            headers.map(header => `"${row[header]}"`).join(',')
        )
    ].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `lake-illawong-data-${new Date().toISOString().split('T')[0]}.csv`;
    link.click();
    
    alert('‚úÖ CSV exported successfully!');
}

function exportChart(chartId) {
    const canvas = document.getElementById(chartId);
    if (canvas) {
        const link = document.createElement('a');
        link.download = `${chartId}-${new Date().toISOString().split('T')[0]}.png`;
        link.href = canvas.toDataURL();
        link.click();
    }
}

// THEME TOGGLE
function toggleTheme() {
    const currentTheme = document.body.getAttribute('data-theme') || 'light';
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    document.body.setAttribute('data-theme', newTheme);
    localStorage.setItem('dashboardTheme', newTheme);
    
    // Update all charts with new theme
    updateCharts();
    
    alert(`‚úÖ Switched to ${newTheme} theme`);
}

// Load saved theme on page load
document.addEventListener('DOMContentLoaded', function() {
    const savedTheme = localStorage.getItem('dashboardTheme') || 'light';
    document.body.setAttribute('data-theme', savedTheme);
});


    </script>




</body>
</html>
